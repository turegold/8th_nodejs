# 4주차 키워드

## 🐶ES
ES(Ecma Script)는 ‘Javascript의 표준 규격’을 의미한다.

넷스케이프 사에서 개발한 Javascript가 인기를 끌기 시작하자 마이크로소프트 사에서도 JScript라는 이름으로 IE(인터넷 익스플로러)에도 적용하였다. Javascript와 JScript가 점점 발전하면서 점점 달라지는 경향을 보였고, 같은 기능을 구현하더라도 개발자들이 해야할 일과 시간이 훨씬 늘어나게 되었다. 이에 보다못한 European Computer Manufactures Association(ECMA)에서 Javascript에 대한 표준을 정하게 되었다.

또, ECMA에서는 Javascript의 표준 뿐만 아니라 다른 표준안도 정하기 때문에 다른 것들과 구분하기 위해 Javascript의 표준 규격은 ECMA 262가 되었다.

## 🐳ES6
## ES6의 주요 변화 및 특징
ES6는 ES2015라고도 한다. ES6에서는 엄청나게 많은 추가점이 생겼다.

1. Hoisting 개선
: 기존에는 var키워드를 사용하여 호이스팅이 빈번하게 일어났는데 이를 방지하기 위해 블록 스코프를 가진 let과 const를 추가하였다.

2. 화살표 문법 지원
: this를 바인딩 하지 않기 때문에 복잡하지 않고, 코드를 간결화할 수 있다.

3. iterator와 generator 추가

4. module의 import/export 추가

5. Promise 도입
: 자바스크립트는 비동기적 언어이기 때문에 callback에 대한 이슈가 많았으나, 이부분을 해결할 수 있게되었다.
## ES6를 중요시 하는 이유
ES6는 자바스크립트의 획기적인 전환점이 되었고, 개발 생산성과 코드의 가독성, 유지보수성을 엄청나게 높여준 버전이기 때문에 중요시하게 여겨진다.
블록 스코프 변수 선언, 화살표 함수, 템플릿 리터럴, 구조 분해 할당, 모듈 시스템 등의 추가로 가독성과 생산성 뿐만 아니라 유지보수성과 협업 편리성이 폭발적으로 향상되었다.
## ES Module
ES Module은 Javascript의 공식 모듈이다.

ES Module의 진행 순서는 3단계로 나뉜다.

1. 구성 - 모든 파일을 찾아 다운로드하고 모듈 레코드로 구문분석을 한다.
2. 인스턴스 화 - export 된 값을 모두 배치하기 위해 메모리에 있는 공간들을 찾는다(아직 실제 값은 채우지 않음). 그 다음 export와 import들이 이런 메모리 공간들을 가리키도록 한다. 이를 연결(linking) 이라고 한다.
3. 평가 - 코드를 실행하여 값을 변수의 실제 값으로 채운다.

### 구성
1. 모듈이 들어있는 파일을 어디서 다운 받을 것인지 확인한다.
2. 파일 가져오기
    진입점 파일 찾기
   ```
   <script src="main.js" type="module">
   ```
   type=”module”을 통해 진입점을 확인한다.
3. 파일 구문 분석

### 인스턴스 화
import와 export 한 것들이 메모리에 연결되어야 한다. 먼저 export부터 연결하는데, 모듈 그래프를 인스턴스 화하기 위해 깊이 우선 탐색(DFS)을 진행한다.
모든 의존의 최하단까지 도달한 후 export를 설정하고, 그 후 import를 연결한다.
Node.js의 모듈 시스템인 CommonJS는 인스턴스 과정에서 export 객체가 메모리에 올라갈 때, 복제된 값이 올라간다. 따라서 인스턴스 과정이 끝나고, export하는 모듈에서 값 수정이 일어나도 import 하는 모듈입장에선 알 수 있는 방법이 없다.
이에 반해 ES 모듈은 라이브 바인딩을 사용하여 export 하는 모듈과 import 하는 모듈이 같은 메모리 주소에 접근한다.

### 평가
메모리에 값을 부여하는 단계이다.
평가 단계에서 한 모듈을 여러 번 실행하게 되면 값이 변경될 수 있기 때문에 한 모듈은 한 번만 평가한다. 따라서 이를 처리하기 위해 모듈맵을 이용하여 깊이 우선 탐색(DFS)를 통해 처리한다.

## 🐜프로젝트 아키텍처
## 프로젝트 아키텍처가 중요한 이유
프로젝트 아키텍처는 프로젝트 구조와 설계 원칙을 의미한다.

프로젝트 아키텍처는

- 유지보수성: 시간이 지나도 쉽게 고치고, 확장하고, 이해할 수 있어야 함
- 협업 효율성: 누가 봐도 어디서 무엇을 수정해야 할지 알 수 있어야 함
- 확장성: 기능이 많아져도 구조가 무너지지 않고 잘 늘어날 수 있어야 함
- 재사용성: 중복 없이 깔끔하게 컴포넌트, 모듈, 함수들을 재사용 가능해야 함
- 테스트 용이성: 관심사 분리가 잘 되어 있으면 테스트도 쉬움

을 담당한다.

❌프로젝트 아키텍처가 잘못 설계되어있는 경우

- 변수명이 통일 되어있지 않음
- 비지니스 로직과 API 호출, UI 코드가 한 파일에 섞여 있음

이러한 경우 기능 하나를 추가하려고 파일 수십 개를 수정하거나, 테스트가 불가능하거나 수정할 때마다 전체 코드가 깨질 가능성이 있다.

✅올바른 프로젝트 아키텍처

- 기능별로 코드가 잘 분리되어 있음 (ex: Controller, Service, Repository)
- 관심사 분리 덕분에 역할이 명확함
- 팀원이 와도 빠르게 적응하고 수정이 가능함
- 기능 추가/수정이 한 방향으로만 퍼짐 (수정 범위가 좁음)

## Service-Oriented Architecture(Service Layer Pattern)
Service-Oriented Architecture(서비스 지향 아키텍처)는 “작은 서비스들”로 쪼개서 각각 독립적으로 만들고 연결해서 사용하는 구조이다.

전통적인 시스템(Monolithic)은 모든 기능이 한 코드에 얽혀있었기 때문에 하나를 고치면 다른 기능이 깨지기 쉬웠다.

그렇기 때문에 SOA(Service-Oriented Architecture)에서는 기능을 서비스 단위로 나누어 각각이 독립적인 서비스를 이루게 하고, 각자 따로 개발/배포/수정이 가능하게 만들어서 네트워크를 통해 서로 메시지로 통신하도록 설계하였다.

이를 통해 유연하고, 재사용성 높고, 협업도 쉬운 설계가 가능해졌다.

ex)

[회원 서비스] → 회원가입, 로그인
[결제 서비스] → 카드 결제, 영수증 발급
[리뷰 서비스] → 후기 작성, 평점
[알림 서비스] → 이메일, 푸시 알림

## MVC 패턴
MVC 패턴은 코드를 역할별로 3개(Model, View, Controller)로 나눠서 개발하는 방식이다.

### 모델(Model)
모델은 애플리케이션의 핵심 데이터와 비즈니스 로직을 나타낸다. 테이터 저장소와의 상호 작용, 데이터 처리 및 유효성 검사와 같은 작업을 수행한다. 모델은 독립적으로 작동하며, View와 Controller와 직접적으로 통신하지 않는다.

### 뷰(View)
뷰는 사용자에게 보여지는 애플리케이션의 UI 부분이다. 뷰는 모델에서 데이터를 받아 사용자에게 표시하고, 사용자의 입력을 컨트롤러에 전달한다. 뷰는 애플리케이션의 데이터 표시와 관련된 모든 작업을 처리한다.

### 컨트롤러(Controller)
MVC패턴의 세 가지 구성 요소는 서로 상호 작용을 하며, 상호작용시 각 요소는 명확하게 정의된 역할을 수행한다.
사용자가 애플리케이션에서 작업을 수행하면, View는 사용자의 입력을 감지하고 Controller에게 전달한다. Controller는 사용자 입력을 처리하고 적절한 Model 기능을 호출하여 데이터를 검색, 수정 또는 저장한다. Model은 데이터와 관련된 비즈니스 로직을 수행하고, 필요한 경우 데이터베이스와 상호 작용한다. Model은 작업이 완료되면 결과를 컨트롤러에 반환한다. Controller는 Model의 결과를 받아 View에 전달하여 View는 이 데이터를 사용하여 사용자에게 보여지는 화면을 업데이트 한다.

## 그 외 다른 프로젝트 구조
비즈니스 로직은 “프로그램이 해결하려는 실제 문제의 규칙”을 의미한다. 쉽게 말하면 “기계적인 처리나 UI랑 상관없이, 서비스만의 핵심 규칙/행동”을 의미한다.
음식 배달 앱을 예시로 들면 비즈니스 로직은

- 결제 성공 시 포인트 적립
- 배달 완료 후 리뷰 작성 가능
- 일정 금액 이상 주문해야 주문 가능
- VIP 고객은 배달비 무료
등이 있다.

이것들은 전부 “이 앱만의 서비스 규칙”이므로, 전부 비즈니스 로직에 해당한다.

## 🐸비즈니스 로직
비즈니스 로직은 “프로그램이 해결하려는 실제 문제의 규칙”을 의미한다. 쉽게 말하면 “기계적인 처리나 UI랑 상관없이, 서비스만의 핵심 규칙/행동”을 의미한다.

음식 배달 앱을 예시로 들면 비즈니스 로직은

- 결제 성공 시 포인트 적립
- 배달 완료 후 리뷰 작성 가능
- 일정 금액 이상 주문해야 주문 가능
- VIP 고객은 배달비 무료

등이 있다.

이것들은 전부 “이 앱만의 서비스 규칙”이므로, 전부 비즈니스 로직에 해당한다.
## DTO
DTO(Data Transfer Object)는 데이터를 주고받기 위한 전용 객체이다.

서버 ↔ 클라이언트, 혹은 계층 ↔ 계층 간에 필요한 데이터만 담아서 전달하는 용도이다.

DTO는 필요한 데이터만 딱 정리해서 주고받기 위해, 보안이나 내부 로직을 숨기기 위해, 프론트와 백엔드 간의 명세를 명확하게 만들기 위해 사용한다.

Controller → Service로  DTO를 보낼 때는 요청 데이터를 정리해서 넘길 때 사용한다.

Service → Controller로 DTO를 보낼 떄는 응답용 데이터를 포장해서 전달할 때 사용한다.

API 응답은 클라이언트가 보는 데이터만 담기 위해 사용한다.
ex)
### User 엔티티
```

{
  id: 1,
  phone_number: "010-1234-5678",
  password: "hashed_password!",
  name: "홍길동",
  created_at: "...",
  updated_at: "..."
}

```
클라이언트에게 보낼 때는 비밀번호, created_at, updated_at은 필요하지 않기 때문에 클라이언트가 필요한 DTO만 클라이언트에게 보낸다.
```

{
  name: "홍길동",
  phone_number: "010-1234-5678"
}

```
